
---

## Tool Requirements: `code-context` (CLI) - *Updated*

**1. Purpose:**
To scan a given directory (or set of subdirectories) within a codebase, analyze the code using a Large Language Model (LLM) based on a user-provided query/topic, optionally generate a file/folder tree, and produce a structured Markdown summary file detailing the findings.

**2. Core Functionality:**
   *   Accept a target directory path and a natural language query as input.
   *   Recursively scan the files and folders within the target directory.
   *   Identify files and code snippets relevant to the user's query.
   *   Interact with an LLM to analyze the relevant code and generate concise summaries for each relevant file.(should support multiple LLMs)
   *   Optionally generate a tree representation of the scanned directory structure.
   *   Compile these summaries (and optionally the tree) into a single Markdown output file.
   *   Optionally treat immediate subdirectories of the target path as separate services/modules and generate summaries for each, organizing the output accordingly.

**3. Command Line Interface (CLI):**
   *   **Command Name:** `code-context` (suggestion)
   *   **Arguments:**
      *   `TARGET_PATH`: The mandatory path to the directory to analyze.
      *   `QUERY`: The mandatory natural language query defining the context to search for (e.g., "what is the usage of kafka in this project", "summarize database interactions"). Should be enclosed in quotes if it contains spaces.
   *   **Options/Flags:**
      *   `-m, --multi-service`: Optional flag. If present, the tool should treat each immediate subdirectory within `TARGET_PATH` as a distinct service. The analysis should be performed independently for each subdirectory, and the final Markdown output should be sectioned by service (using the subdirectory name as a header).
      *   `-o, --output <FILENAME>`: Optional flag. Specify the name for the output Markdown file (e.g., `-o kafka_usage.md`). Defaults to `CODE_CONTEXT_SUMMARY.md` in the current working directory.
      *   `--llm-api-key <KEY>`: Optional (or configure via environment variable). The API key for the LLM service.
      *   `--llm-endpoint <URL>`: Optional (or configure via environment variable). The endpoint for the LLM service if using a self-hosted or non-standard model.
      *   `--ignore <PATTERN>`: Optional, repeatable. Glob patterns for files/directories to ignore during scanning (e.g., `--ignore node_modules --ignore *.log`). Could also potentially read from a `.gitignore` file by default.
      *   **`--show-tree`**: **(New)** Optional flag. If present, include a representation of the scanned directory structure in the Markdown output. The tree should ideally be filtered to show only the paths relevant to the summarized files or pruned to a reasonable depth to avoid excessive length.
   *   **Usage Examples:**
      ```bash
      # Analyze a single service/directory for Kafka usage
      code-context ./my-service/ --query "Explain the Kafka integration points"

      # Analyze multiple services within a parent directory for Cosmos DB usage
      code-context ./all-services/ --query "Summarize Cosmos DB usage" -m

      # Specify output file name
      code-context ./project-x/ --query "Document the main API endpoints" -o API_Endpoints.md

      # Analyze and include a directory tree structure in the output
      code-context ./complex-project/ --query "Identify database models" --show-tree
      ```

**4. Processing Logic:**
   *   **Directory Traversal:** Efficiently walk the directory structure specified by `TARGET_PATH`.
   *   **File Filtering:** (Same as before - ignore binaries, VCS, dependencies, apply `--ignore`, focus on source code).
   *   **Relevance Identification (Pre-LLM):** (Same as before - keyword or semantic search to filter files for LLM).
   *   **LLM Interaction:** (Same as before - prompt construction, API calls, error handling, context limits).
   *   **Summary Aggregation:** Collect the summaries generated by the LLM for each relevant file.
   *   **Tree Generation (if `--show-tree`):** If the flag is present, generate a tree structure string representing the scanned directories and files. This should respect ignore patterns. Consider filtering the tree to primarily show paths containing relevant files or limiting the depth.

**5. Output Generation (Markdown):**
   *   Create a Markdown file (default: `CODE_CONTEXT_SUMMARY.md`, or specified by `-o`).
   *   **Structure (Single Mode, `--show-tree` enabled):**
      ```markdown
      # Code Context Summary

      **Query:** [User's Query]
      **Target Directory:** [Target Path]

      ---

      ## Directory Structure

      ```
      [Generated Tree Structure, potentially filtered/pruned]
        ├── folder1/
        │   └── relevant_file1.ext (*)
        ├── folder2/
        │   ├── subfolder/
        │   └── irrelevant_file.ext
        └── relevant_file2.ext (*)
      ```
      (* Indicates files included in the summaries below)


      ---

      ## File Summaries

      ### `path/to/relevant/file1.ext`
      [LLM-generated summary for file1]

      ### `path/to/relevant/file2.ext`
      [LLM-generated summary for file2]

      ...
      ```
   *   **Structure (Single Mode, `--show-tree` disabled):** *(Same as original)*
      ```markdown
      # Code Context Summary

      **Query:** [User's Query]
      **Target Directory:** [Target Path]

      ---

      ## File Summaries

      ### `path/to/relevant/file1.ext`
      [LLM-generated summary for file1]

      ### `path/to/another/relevant/file2.ext`
      [LLM-generated summary for file2]

      ...
      ```
   *   **Structure (Multi-Service Mode - `-m`):** The tree (if enabled) would likely appear *before* the first service section, showing the overall structure containing the subdirectories identified as services. Alternatively, a smaller tree could be generated within each service's section. The first option is probably simpler.

**6. Language Choice:**
   *   Go
   * Make sure to follow https://go.dev/doc/effective_go for better code standard 
   * Since we are using the latest go, make sure to use all the latest stuff like modules etc

**7. Non-Functional Requirements:**
   *   (Same as before - Configuration, Error Handling, Performance, Extensibility).

---

